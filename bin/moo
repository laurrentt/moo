#!/usr/bin/env node
'use strict';

var express    = require('express'),
    path       = require('path'),
    fs         = require('fs'),
    util       = require('util'),
    jade       = require('jade'),
    open       = require('open'),
    marked     = require('marked'),
    program    = require('commander'),
    pygmentize = require('pygmentize-bundled'),
    watch      = require('chokidar').watch,
    async      = require('async'),
    pkg        = require('../package.json'),
    version    = pkg.version;

// CLI

program
  .version(version)
  .option('-e, --export', 'export rendered HTML instead preview')
  .option('-p, --port <n>', 'server port (defaults to random)', parseInt, 0);

program.on('help', function () {
  [
    '  Examples:',
    '',
    '    $ moo [-p 8080] README.md',
    '    $ moo -e *.md',
    '    $ cat README.md | moo -e - | less',
    '',
  ].forEach(console.error);
});

program.parse(process.argv);

var isatty = process.stderr.isTTY;

// Resources

program.views = __dirname + '/../resources/views';
program.static = __dirname + '/../resources/static';

// Marked

var renderer = new marked.Renderer();

renderer.code = function (text, lang) {
  if (!lang) {
    return '<pre><code>' + text + '\n</code></pre>';
  } else {
    // return identity since Pygments already wrapped the code.
    return text;
  }
};

marked.setOptions({
  renderer: renderer
});

function highlight (code, lang, callback) {
  var options = {
    lang: lang,
    format: 'html',
    options: {
      cssclass: util.format('highlight highlight-%s', lang),
    },
  };
  pygmentize(options, code, function (err, result) {
    callback(err, result.toString());
  });
}

// Logging

require('colour');

function logger (name, color, post) {
  return function () {
    var msg = util.format.apply(null, arguments);
    var prefix = name[color].bold + ' - '.grey;

    msg.split('\n').forEach(function (line) {
      var out = prefix + line;
      if (!isatty)
        out = out.stripColors;
      console.error(out);
    });
    if (post) post();
  };
}

var fatal = logger('fatal', 'red', function () { process.exit(1); }),
    error = logger('error', 'red'),
    info  = logger('info', 'cyan'),
    ok    = logger('ok', 'green');

// Preview

function preview () {
  var app = express();
  var filename, server, url;

  if (program.args.length !== 1)
    fatal('expect one input file.');

  filename = program.args[0];

  // all environments
  app.set('views', program.views);
  app.set('view engine', 'jade');
  app.use('/', express.static(path.dirname(fs.realpathSync(filename))));
  app.use('/__moo__', express.static(program.static));

  // routers
  app.get('/', function (req, res) {
    res.render('index');
  });

  app.get('/content', function (req, res){
    fs.readFile(filename, function (err, buffer) {
      if (err) fatal(err);
      parse(filename, buffer.toString(), function (err, content) {
        if (err) fatal(err);
        res.json(content);
      });
    });
  });

  app.get('/update-event', function (req, res) {
    var watcher = watch(filename, { persistent: true });

    // server-sent event
    req.socket.setTimeout(0);
    res.set({
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
    });
    res.on('close', function () {
      watcher.close();
    });

    // watcher
    watcher.on('change', function () {
      ok('render %s', filename);
      res.write('data: update\n\n');
    }).on('unlink', function () {
      error('%s is removed', filename);
    }).on('error', function (err) {
      fatal(err);
    });
  });

  process.on('exit', function () {
    server.close();
  });

  server = app.listen(program.port);
  url = 'http://localhost:' + server.address().port;
  ok('Server listening at %s. Press Ctrl-C to stop.', url.underline);

  // open URL
  open(url);
}

// Export

function exports () {
  var template = program.views + '/export.jade',
      files = program.args.slice();

  template = jade.compileFile(template);

  function readStdin (callback) {
    var buf = new Buffer(0);
    process.stdin.on('error', function (err) {
      callback(err);
    });
    process.stdin.on('data', function (chunk) {
      buf = Buffer.concat([buf, chunk]);
    });
    process.stdin.on('end', function () {
      callback(null, buf);
    });
  }

  async.each(files, function (src, onerror) {
    var dest = src.replace(/\.[^\/.]+$/, '.html');
    if (src == '-') {
      // STDIN -> STDOUT
      async.waterfall([
        readStdin,
        function (buf, callback) {
          parse('STDIN', buf, callback);
        },
        function (data, callback) {
          var html = template(data);
          process.stdout.write(html + '\n', callback);
        },
      ], onerror);
    } else {
      async.waterfall([
        // src -> dest
        function (callback) {
          fs.readFile(src, callback);
        },
        function (buf, callback) {
          parse(src, buf, callback);
        },
        function (data, callback) {
          var html = template(data);
          fs.writeFile(dest, html, callback);
        },
        function () {
          ok('%s -> %s', src, dest);
        },
      ], onerror);
    }
  }, function (err) {
    if (err) error(err);
  });
}

// Render

function parse (filename, text, callback) {
  var title = path.basename(filename);
  var hasTitle = false;

  text = text.toString();

  // strip front-matter
  (function stripFrontmatter () {
    var mainmatter, match;
    if (/^-{3}\n/.test(text)) {
      mainmatter = text.split('---\n');
      mainmatter.shift();
      if (mainmatter.length >= 2) {
        match = /(?:^|\n)title:\s*(.+)/i.exec(mainmatter.shift());
        if (match) {
          hasTitle = true;
          title = match[1];
        }
        text = mainmatter.join('---\n');
      }
    }
  })();

  var tokens = marked.lexer(text);
  if (!hasTitle) {
    var first = tokens[0];
    if (first && first.type === 'heading' && first.depth === 1) {
      title = first.text;
    }
  }

  async.each(tokens, function (token, callback) {
    if (token.type === 'code' && token.lang) {
      // highlight tokens
      highlight(token.text, token.lang, function (err, code) {
        if (err) {
          callback(err);
        } else {
          if (code !== null && code !== token.text) {
            token.text = code;
            token.escaped = true;
          }
          callback();
        }
      });
    } else {
      callback();
    }
  }, function (err) {
    if (err) {
      error(err);
    } else {
      var html = marked.parser(tokens);
      callback(null, { title: title, html: html });
    }
  });
}

if (program.export) {
  exports();
} else {
  preview();
}
